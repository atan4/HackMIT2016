<html> 
<head> 
<meta name="viewport" content="initial-scale=1.0, user-scalable=no" /> 
<meta http-equiv="content-type" content="text/html; charset=UTF-8"/> 
<title>Google Maps JavaScript API v3 Example: Rhumb vs Geodesic Polylines</title> 
<script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=false"></script> 
<script type="text/javascript" src="v3_epoly.js"></script>

<script type="text/javascript"> 
// from http://en.wikipedia.org/wiki/Earth_radius
/*
/ Equatorial radius
/ The Earth's equatorial radius a, or semi-major axis, is the distance from its center to the equator and equals 6,378.1370 km (?3,963.191 mi; ?3,443.918 nmi).
*/
var EarthRadiusMeters = 6378137.0; // meters
/* Based the on the Latitude/longitude spherical geodesy formulae & scripts
   at http://www.movable-type.co.uk/scripts/latlong.html
   (c) Chris Veness 2002-2010
*/ 
google.maps.LatLng.prototype.DestinationPoint = function (brng, dist) {
  var R = EarthRadiusMeters; // earth's mean radius in meters
var brng = brng.toRad();
var lat1 = this.lat().toRad(), lon1 = this.lng().toRad();
var lat2 = Math.asin( Math.sin(lat1)*Math.cos(dist/R) + 
                      Math.cos(lat1)*Math.sin(dist/R)*Math.cos(brng) );
var lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(dist/R)*Math.cos(lat1), 
                             Math.cos(dist/R)-Math.sin(lat1)*Math.sin(lat2));

return new google.maps.LatLng(lat2.toDeg(), lon2.toDeg());
}

/* Based the on the Latitude/longitude spherical geodesy formulae & scripts
   at http://www.movable-type.co.uk/scripts/latlong.html
   (c) Chris Veness 2002-2010
*/ 
google.maps.LatLng.prototype.rhumbDestinationPoint = function (brng, dist) {
  var R = EarthRadiusMeters; // earth's mean radius in meters
  var d = parseFloat(dist) / R;  // d = angular distance covered on earth's surface
  var lat1 = this.lat().toRad(), lon1 = this.lng().toRad();
  brng = brng.toRad();

  var lat2 = lat1 + d * Math.cos(brng);
  var dLat = lat2 - lat1;
  var dPhi = Math.log(Math.tan(lat2 / 2 + Math.PI / 4) / Math.tan(lat1 / 2 + Math.PI / 4));
  var q = (Math.abs(dLat) > 1e-10) ? dLat / dPhi : Math.cos(lat1);
  var dLon = d * Math.sin(brng) / q;
  // check for going past the pole
  if (Math.abs(lat2) > Math.PI / 2) {
    lat2 = lat2 > 0 ? Math.PI - lat2 : - (Math.PI - lat2);
  }
  var lon2 = (lon1 + dLon + Math.PI) % (2 * Math.PI) - Math.PI;
 
  if (isNaN(lat2) || isNaN(lon2)) {
    alert("bad Rhumb Destination Point");
    return null;
  }
  return new google.maps.LatLng(lat2.toDeg(), lon2.toDeg());
};

/** 
 * Returns the distance from this point to the supplied point, in km, travelling along a rhumb line 
 * 
 *   see http://williams.best.vwh.net/avform.htm#Rhumb 
 * 
 * @param   {LatLon} point: Latitude/longitude of destination point 
 * @returns {Number} Distance in meters between this point and destination point 
 */ 
/* Based the on the Latitude/longitude spherical geodesy formulae & scripts
   at http://www.movable-type.co.uk/scripts/latlong.html
   (c) Chris Veness 2002-2010
*/ 
google.maps.LatLng.prototype.rhumbDistanceTo = function(point) { 
  var R = EarthRadiusMeters; // earth's mean radius in meters
  var lat1 = this.lat().toRad(), lat2 = point.lat().toRad(); 
  var dLat = (point.lat()-this.lat()).toRad(); 
  var dLon = Math.abs(point.lng()-this.lng()).toRad(); 
   
  var dPhi = Math.log(Math.tan(lat2/2+Math.PI/4)/Math.tan(lat1/2+Math.PI/4)); 
  var q = (!isNaN(dLat/dPhi) && isFinite(dLat/dPhi)) ? dLat/dPhi : Math.cos(lat1);  // E-W line gives dPhi=0 
  // if dLon over 180� take shorter rhumb across 180� meridian: 
  if (dLon > Math.PI) dLon = 2*Math.PI - dLon; 
  var dist = Math.sqrt(dLat*dLat + q*q*dLon*dLon) * R;  
   
  return dist;  // 4 sig figs reflects typical 0.3% accuracy of spherical model 
} 

/**
 * Extend the Number object to convert degrees to radians
 *
 * @return {Number} Bearing in radians
 * @ignore
 */ 
Number.prototype.toRad = function () {
  return this * Math.PI / 180;
};

/**
 * Extend the Number object to convert radians to degrees
 *
 * @return {Number} Bearing in degrees
 * @ignore
 */ 
Number.prototype.toDeg = function () {
  return this * 180 / Math.PI;
};

/**
 * Normalize a heading in degrees to between 0 and +360
 *
 * @return {Number} Return 
 * @ignore
 */ 
Number.prototype.toBrng = function () {
  return (this.toDeg() + 360) % 360;
};

var infowindow = new google.maps.InfoWindow(
  { 
    size: new google.maps.Size(150,50)
  });

var map = null;
var bounds = null;
var gpolys = [];

function createMarker(latlng, title, html) {
    var contentString = html;
    // var marker = new google.maps.Marker({
    //     position: latlng,
    //     map: map,
    //     zIndex: Math.round(latlng.lat()*-100000)<<5
    //     });

    google.maps.event.addListener(marker, 'click', function() {
        infowindow.setContent(contentString); 
        // infowindow.open(map,marker);
        });
    // return marker;
}

      function createClickablePoly(poly, html, label, point) {
        gpolys.push(poly);
        if (!point && poly.getPath 
                   && poly.getPath().getLength 
                   && (poly.getPath().getLength > 0) 
                   && poly.getPath().getAt(0)) { point = poly.getPath().getAt(0); } 
        var poly_num = gpolys.length - 1;
        if (!html) {html = "";}
        else { html += "<br>";}
        var length = poly.Distance();
	if (length > 1000) {
          html += "length="+poly.Distance().toFixed(3)/1000+" km";
	} else {
          html += "length="+poly.Distance().toFixed(3)+" meters";
        }
        for (var i=0;i<poly.getPath().getLength();i++) {
           html += "<br>poly["+poly_num+"]["+i+"]="+poly.getPath().getAt(i);
        }
	html += "<br>Area: "+poly.Area()+" sq meters";
        // html += poly.getLength().toFixed(2)+" m; "+(poly.getLength()*3.2808399).toFixed(2)+" ft; ";
        // html += (poly.getLength()*0.000621371192).toFixed(2)+" miles";
        var contentString = html;
        google.maps.event.addListener(poly,'click', function(event) {
          infowindow.setContent(contentString);
          if (event) {
             point = event.latLng;
          }
          infowindow.setPosition(point);
          infowindow.open(map);
          // map.openInfoWindowHtml(point,html); 
        }); 
        if (!label) {
          label = "polyline #"+poly_num;
        }
        label = "<a href='javascript:google.maps.event.trigger(gpolys["+poly_num+"],\"click\");'>"+label+"</a>";
        // add a line to the sidebar html
        //  side_bar_html += '<input type="checkbox" id="poly'+poly_num+'" checked="checked" onclick="togglePoly('+poly_num+');">' + label + '<br />';
      }

function initialize() {
  var myOptions = {
    zoom: 2,
    center: new google.maps.LatLng(10, 0),
    navigationControl: true,
    mapTypeId: google.maps.MapTypeId.ROADMAP,
    styles: [
      {
        featureType: 'road',
        elementType: 'geometry',
        stylers: [
          { color: '#FFFFFF' },
          { weight: 1.6 }
        ]
      }, {
        featureType: 'road',
        elementType: 'labels',
        stylers: [
          { saturation: -100 },
          { invert_lightness: true }
        ]
      }, {
        featureType: 'landscape',
        elementType: 'geometry',
        stylers: [
          { hue: '#FFFFFF' },
          { gamma: 1.4 },
          { saturation: -80 },
          { lightness: 96 }
        ]
      }, {
        featureType: 'poi.school',
        elementType: 'geometry',
        stylers: [
          { hue: '#FFFFFF' },
          { lightness: -15 },
          { saturation: 99 }
        ]
      }, {
        featureType: 'poi',
        elementType: 'geometry',
        stylers: [
          { visibility: 'off' }
        ]
      }, {
        featureType: 'poi.school',
        elementType: 'geometry',
        stylers: [
          { visibility: 'on' },
          { hue: '#FFFFFF' },
          { lightness: -15 },
          { saturation: 99 }
        ]
      }, {
        featureType: 'water',
        stylers: [
          {color: '#02081E'},
        ]
      }]
  }
  map = new google.maps.Map(document.getElementById("map_canvas"),
                                myOptions);
 
  google.maps.event.addListener(map, 'click', function() {
        infowindow.close();
        });
  bounds = new google.maps.LatLngBounds();

  var leftPoint = new google.maps.LatLng(32.7384,-117.14);

  bounds.extend(leftPoint);
  var rightPointRhumb = leftPoint.rhumbDestinationPoint(90,2000000);
  bounds.extend(rightPointRhumb);
  var rightPointGeodesic = leftPoint.DestinationPoint(90,2000000);
  bounds.extend(rightPointGeodesic);
  
  var rhumbLine = new google.maps.Polyline({
                 path:[leftPoint, rightPointRhumb],
                 strokeColor: "#000000",
                 strokeOpacity: 0.8,
                 map: map,
                 strokeWeight: .5
		 });

  var rhumbLine = new google.maps.Polyline({
                 path:[leftPoint, rightPointRhumb],
                 strokeColor: "#000000",
                 strokeOpacity: 0.8,
                 map: map,
                 geodesic:true,
                 strokeWeight: .5
		 });

  var destinationLine = new google.maps.Polyline({
                 path:[leftPoint, rightPointGeodesic],
                 strokeColor: "#000000",
                 strokeOpacity: 0.8,
                 map: map,
                 strokeWeight: .5
		 });
  var destinationLineGeodesic = new google.maps.Polyline({
                 path:[leftPoint, rightPointGeodesic],
                 strokeColor: "#000000",
                 strokeOpacity: 0.8,
                 map: map,
                 geodesic:true,
                 strokeWeight: .5
		 });

 createMarker(leftPoint, "left", "<b>origin</b><br>left:"+leftPoint.toUrlValue(6)+"<br>right:"+rightPointRhumb.toUrlValue(6)+"<br>distance="+(rhumbLine.Distance()/1000).toFixed(3)+" km");
 
 createMarker(rightPointRhumb, "right rhumb", "<font color='blue'><b>.rhumbDestinationPoint(90,2000km)</b></font><br>left:"+leftPoint.toUrlValue(6)+"<br>right:"+rightPointRhumb.toUrlValue(6)+"<br>great circle distance="+(leftPoint.distanceFrom(rightPointRhumb)/1000).toFixed(3)+" km<br><font color='blue'>rhumb distance="+(leftPoint.rhumbDistanceTo(rightPointRhumb)/1000).toFixed(3)+" km</font>");
 
 createMarker(rightPointGeodesic, "right rhumb", "<font color='red'><b>.DestinationPoint(90,2000km)</b></font><br>left:"+leftPoint.toUrlValue(6)+"<br>right:"+rightPointGeodesic.toUrlValue(6)+"<br><font color='red'>great circle distance="+(leftPoint.distanceFrom(rightPointGeodesic)/1000).toFixed(3)+" km</font><br>rhumb distance="+(leftPoint.rhumbDistanceTo(rightPointGeodesic)/1000).toFixed(3)+" km");
  map.fitBounds(bounds);
   
}

</script> 
</head> 
<body style="margin:0px; padding:0px;" onload="initialize()"> 
  <table border="1" style="height:100%; width:100%"><tr><td><div id="map_canvas" style="width:100%; height:100%"></div> 
</td><td width="200"><div id="report"></div></td></tr></table>
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"> 
</script> 
<script type="text/javascript"> 
_uacct = "UA-162157-1";
urchinTracker();
</script> 
</body> 
</html> 
